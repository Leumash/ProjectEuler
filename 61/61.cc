/*

Cyclical figurate numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle        P_{3,n}=n(n+1)/2       1, 3, 6, 10, 15, ...
Square          P_{4,n}=n^2            1, 4, 9, 16, 25, ...
Pentagonal      P_{5,n}=n(3n−1)/2      1, 5, 12, 22, 35, ...
Hexagonal       P_{6,n}=n(2n−1)        1, 6, 15, 28, 45, ...
Heptagonal      P_{7,n}=n(5n−3)/2      1, 7, 18, 34, 55, ...
Octagonal       P_{8,n}=n(3n−2)        1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).

2. Each polygonal type: triangle (P_{3,127}=8128), square (P_{4,91}=8281), and pentagonal (P_{5,44}=2882), is represented by a different number in the set.

3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

*/

#include <iostream>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <numeric>

using namespace std;

class Graph
{
    public:
        void AddVertex(int vertex);
        void AddVertices(const vector<int> &toAdd);
        vector<vector<int>> GetCycles(int length) const;
    private:
        unordered_map<int, vector<int> > adjacencyList;

        void AddEdgesFromOthersToSelf(int vertex);
        void AddEdgesFromSelfToOthers(int vertex);

        auto GetCycles(int vertex, int length) const;

        void DFS(unordered_set<int> visited, vector<int> currentPath, int length, auto &toReturn) const;
};

void Graph::DFS(unordered_set<int> visited, vector<int> currentPath, int length, auto &toReturn) const
{
    int currentVertex = currentPath[currentPath.size() - 1];

    for (const int &neighbor : adjacencyList.at(currentVertex))
    {
        if (visited.count(neighbor) > 0)
        {
            // Found a cycle

            if (neighbor == currentPath[0])
            {
                // Only desire cycles which leads back to beginning vertex
                if (currentPath.size() == length)
                {
                    toReturn.push_back(currentPath);

                    // Break for efficiency
                    break;
                }
            }

        }
        else
        {
            // Not a cycle

            // Don't continue at cycles that will be longer than length
            if (currentPath.size() < length)
            {
                visited.insert(neighbor);
                currentPath.push_back(neighbor);

                DFS(visited, currentPath, length, toReturn);

                visited.erase(neighbor);
                currentPath.pop_back();
            }
        }
    }
}

auto Graph::GetCycles(int vertex, int length) const
{
    // Only find cycles which cycle back to 'vertex'

    vector<vector<int>> toReturn;

    unordered_set<int> visited;
    vector<int> currentPath;

    visited.insert(vertex);
    currentPath.push_back(vertex);

    DFS(visited, currentPath, length, toReturn);

    return toReturn;
}

vector< vector<int> > Graph::GetCycles(int length) const
{
    vector< vector<int> > toReturn;

    for (const auto &vertexToEdges : adjacencyList)
    {
        auto cycles = GetCycles(vertexToEdges.first, length);

        toReturn.insert(toReturn.end(), cycles.begin(), cycles.end());
    }

    return toReturn;
}

void Graph::AddEdgesFromOthersToSelf(int vertex)
{
    int firstTwoDigits = vertex / 100;

    for (const auto &vertexToEdges : adjacencyList)
    {
        int currentVertex = vertexToEdges.first;
        int lastTwoDigits = currentVertex % 100;

        if (firstTwoDigits == lastTwoDigits)
        {
            adjacencyList[currentVertex].push_back(vertex);
        }
    }
}

void Graph::AddEdgesFromSelfToOthers(int vertex)
{
    int lastTwoDigits = vertex % 100;

    for (const auto &vertexToEdges : adjacencyList)
    {
        int currentVertex = vertexToEdges.first;
        int firstTwoDigits = currentVertex / 100;

        if (lastTwoDigits == firstTwoDigits)
        {
            adjacencyList[vertex].push_back(currentVertex);
        }
    }
}

void Graph::AddVertex(int vertex)
{
    if (adjacencyList.count(vertex) == 0)
    {
        adjacencyList[vertex] = vector<int>();

        AddEdgesFromOthersToSelf(vertex);
        AddEdgesFromSelfToOthers(vertex);
    }
}

void Graph::AddVertices(const vector<int> &toAdd)
{
    for (int vertex : toAdd)
    {
        AddVertex(vertex);
    }
}

int GetDigits(int n)
{
    return to_string(n).size();
}

int TriangleNumber(int n)
{
    return (n * (n + 1)) / 2;
}

int SquareNumber(int n)
{
    return n * n;
}

int PentagonalNumber(int n)
{
    return (n * (3 * n - 1)) / 2;
}

int HexagonalNumber(int n)
{
    return n * (2 * n - 1);
}

int HeptagonalNumber(int n)
{
    return (n * (5 * n - 3)) / 2;
}

int OctagonalNumber(int n)
{
    return n * (3 * n - 2);
}

vector<int> GetFigurateNumbers(int (*figurateFunction)(int), int desiredDigits)
{
    vector<int> figurateNumbers;

    for (int n = 1; ; ++n)
    {
        int figurateNumber = figurateFunction(n);
        int digits = GetDigits(figurateNumber);

        if (digits == desiredDigits)
        {
            figurateNumbers.push_back(figurateNumber);
        }
        else if (digits > desiredDigits)
        {
            break;
        }
    }

    return figurateNumbers;
}

bool DoesFitUniquelyIntoEachSet(vector<int> setOfNumbers, vector<unordered_set<int>> sets)
{
    if (setOfNumbers.size() == 1)
    {
        return sets[0].count(setOfNumbers[0]) > 0;
    }

    for (int i=0; i<setOfNumbers.size(); ++i)
    {
        for (int j=0; j<sets.size(); ++j)
        {
            if (sets[j].count(setOfNumbers[i]) > 0)
            {
                vector<int> tempSetOfNumbers(setOfNumbers);
                vector<unordered_set<int>> tempSets(sets);

                tempSetOfNumbers.erase(tempSetOfNumbers.begin() + i);
                tempSets.erase(tempSets.begin() + j);

                if (DoesFitUniquelyIntoEachSet(tempSetOfNumbers, tempSets))
                {
                    return true;
                }
            }
        }
    }

    return false;
}

vector<int> GetSetWithANumberInEachSet(const auto &setsOfNumbers, const auto &x1, const auto &x2, const auto &x3, const auto &x4, const auto &x5, const auto &x6)
{
    vector<unordered_set<int>> sets;

    sets.push_back(unordered_set<int>(x1.begin(), x1.end()));
    sets.push_back(unordered_set<int>(x2.begin(), x2.end()));
    sets.push_back(unordered_set<int>(x3.begin(), x3.end()));
    sets.push_back(unordered_set<int>(x4.begin(), x4.end()));
    sets.push_back(unordered_set<int>(x5.begin(), x5.end()));
    sets.push_back(unordered_set<int>(x6.begin(), x6.end()));

    for (const auto &setOfNumbers : setsOfNumbers)
    {
        if (DoesFitUniquelyIntoEachSet(setOfNumbers, sets))
        {
            return setOfNumbers;
        }
    }

    // Should never occur
    return vector<int>();
}

int GetSumOfOrderedSetOfSixCyclicFourDigitNumbers()
{
    vector<int> triangleNumbers = GetFigurateNumbers(&TriangleNumber, 4);
    vector<int> squareNumbers = GetFigurateNumbers(&SquareNumber, 4);
    vector<int> pentagonalNumbers = GetFigurateNumbers(&PentagonalNumber, 4);
    vector<int> hexagonalNumbers = GetFigurateNumbers(&HexagonalNumber, 4);
    vector<int> heptagonalNumbers = GetFigurateNumbers(&HeptagonalNumber, 4);
    vector<int> octagonalNumbers = GetFigurateNumbers(&OctagonalNumber, 4);

    Graph graph;
    graph.AddVertices(triangleNumbers);
    graph.AddVertices(squareNumbers);
    graph.AddVertices(pentagonalNumbers);
    graph.AddVertices(hexagonalNumbers);
    graph.AddVertices(heptagonalNumbers);
    graph.AddVertices(octagonalNumbers);

    vector<vector<int>> cycles = graph.GetCycles(6);

    vector<int> cycleWithANumberInEachSet = GetSetWithANumberInEachSet(cycles,
        triangleNumbers, squareNumbers, pentagonalNumbers,
        hexagonalNumbers, heptagonalNumbers, octagonalNumbers);

    return accumulate(cycleWithANumberInEachSet.begin(), cycleWithANumberInEachSet.end(), 0);
}

int main()
{
    cout << GetSumOfOrderedSetOfSixCyclicFourDigitNumbers() << endl;

    return 0;
}

