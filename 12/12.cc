/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
 10: 1,2,5,10
 15: 1,3,5,15
 21: 1,3,7,21
 28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*/

#include <iostream>
#include <set>
#include <vector>
#include <cmath>

using namespace std;

bool IsPrime(int candidatePrime, const vector<int> &primesInOrder)
{
    for (int i=0; i<primesInOrder.size(); ++i)
    {
        // Optimization
        if (primesInOrder[i] > sqrt(candidatePrime))
        {
            return true;
        }

        if (candidatePrime % primesInOrder[i] == 0)
        {
            return false;
        }
    }

    return true;
}

int GetNextPrime(const vector<int> &primesInOrder)
{
    if (primesInOrder.size() == 0)
    {
        return 2;
    }
    else if (primesInOrder.size() == 1)
    {
        return 3;
    }


    int currentLargestPrime = primesInOrder[primesInOrder.size() - 1];
    int candidatePrime = currentLargestPrime;

    while (true)
    {
        candidatePrime += 2;

        if (IsPrime(candidatePrime, primesInOrder))
        {
            return candidatePrime;
        }
    }
}

multiset<int> GetPrimeFactors(int n, vector<int> &primesInOrder)
{
    multiset<int> toReturn;

    // Check if prime factorization of primesInOrder
    for (int i=0; i<primesInOrder.size(); ++i)
    {
        while (n % primesInOrder[i] == 0)
        {
            toReturn.insert(primesInOrder[i]);
            n /= primesInOrder[i];
        }
    }

    // Check if next prime, and add next prime to primesInOrder
    while (n > 1)
    {
        int nextPrime = GetNextPrime(primesInOrder);

        primesInOrder.push_back(nextPrime);

        while (n % nextPrime == 0)
        {
            toReturn.insert(nextPrime);
            n /= nextPrime;
        }
    }

    return toReturn;
}

vector<int> LoadSomePrimes()
{
    vector<int> toReturn;

    toReturn.push_back(2);
    toReturn.push_back(3);

    return toReturn;
}

set<int> GetDivisors(const multiset<int> &primeFactors)
{
    set<int> toReturn;
    toReturn.insert(1);

    for (multiset<int>::const_iterator mit = primeFactors.begin(); mit != primeFactors.end(); ++mit)
    {
        set<int> toAdd;

        for (set<int>::iterator sit = toReturn.begin(); sit != toReturn.end(); ++sit)
        {
            toAdd.insert(*mit * *sit);
        }

        for (set<int>::iterator sit = toAdd.begin(); sit != toAdd.end(); ++sit)
        {
            toReturn.insert(*sit);
        }
    }

    return toReturn;
}

int GetNumberOfDiviors(int n)
{
    vector<int> primesInOrder = LoadSomePrimes();
    multiset<int> primeFactors = GetPrimeFactors(n, primesInOrder);

    set<int> divisors = GetDivisors(primeFactors);

    return divisors.size();
}

int GetTriangleNumberWithAmountOfDivisorsOver(int n)
{
    int currentTriangleNumber = 1;
    int nthTriangleNumber = 1;

    while (true)
    {
        int numberOfDivisors = GetNumberOfDiviors(currentTriangleNumber);

        if (numberOfDivisors > n)
        {
            return currentTriangleNumber;
        }

        ++nthTriangleNumber;
        currentTriangleNumber += nthTriangleNumber;
    }
}

int main()
{
    cout << GetTriangleNumberWithAmountOfDivisorsOver(500) << endl;
}

